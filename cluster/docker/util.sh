#!/bin/bash

# Copyright 2015 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
set -e

# Set the path of kubectl
KUBECTL_PATH="${KUBE_ROOT}/cluster/docker/kubectl"

# Populate all the ENVs
source "${KUBE_ROOT}/cluster/docker/${KUBE_CONFIG_FILE-"config-default.sh"}"

# Verify ENVs are set & prerequisite are available
# 
# Assumed vars:
#   MASTER 
#   NODES
#   INFRA
function verify-prereqs {
  # Make sure env is properly set
  : ${MASTER?"Need to set MASTER"}
  : ${NODES?"Need to set NODES"}

  case "$INFRA" in
  "baremetal")
      echo "Infra type is set to: $INFRA"
      ;;
  *) 
      echo "Infra type for $INFRA is not implemented yet, welcome to contribute!"
      exit 1
      ;;
  esac

  # Call the function defined in specific infra provider 
  source $KUBE_ROOT/cluster/docker-$INFRA/util.sh
  verify-prereqs-$INFRA
}

# Verify cluster
# 
# Assumed vars:
#   INFRA
function validate-cluster {
  sleep 5 # For now we just sleep to wait the world

  # TODO(harryz) we will use hyperkube kubectl eventually
  get_kubectl

  validate-cluster-$INFRA

  echo
  echo "Kubernetes-in-docker cluster is deployed.  The master should be running at:"
  echo
  echo "  http://${MASTER_IP}:8080"
}

# Remove this when hyperkube has kubectl
function get_kubectl() {
  echo "... Downloading and instll kubectl"
  sudo apt-get install -y curl
  curl https://storage.googleapis.com/kubernetes-release/release/v$K8S_VERSION/bin/linux/amd64/kubectl -o kubectl
  sudo mv kubectl ${KUBE_ROOT}/cluster/docker/
  sudo chmod +x $KUBECTL_PATH
}


# Detect the IP for the master, this will be user in cluster/kubctl.sh
#
# Assumed vars:
#   MASTER
#   MASTER_IP
# Vars set:
#   KUBE_MASTER
#   KUBE_MASTER_IP
function detect-master {
  KUBE_MASTER=$MASTER
  KUBE_MASTER_IP=$MASTER_IP
  echo "Using master $MASTER_IP"
}

# Instantiate a kubernetes cluster on docker
#
# Assumed vars:
#   MASTER
#   NODES
#   NODE_ONLY
# Vars set:
#   KUBE_ROOT
#   NUM_MINIONS
#   REGISTER_MASTER_KUBELET
function kube-up() {

  NUM_MINIONS=0
  REGISTER_MASTER_KUBELET=""

  # Determine if there's any Node want to register itself as Master
  for node in $NODES
  do
    {
      if [ "$node" == $MASTER ]; then
        echo "... NOTICE: $node will be deployed as both Master and Node"
        REGISTER_MASTER_KUBELET="yes"
      fi
    }
  done

  # Generate ENVs used to deploy master and nodes
  generate_env

  # Deploy Master separately
  if [[ "yes" != $NODE_ONLY ]]; then
    deploy-node-master
  fi
 
  # Deploy all the Nodes
  for node in $NODES
  do
    {
      if [ "$node" != $MASTER ]; then
        deploy-node ${node#*@}
      fi
      NUM_MINIONS=$((NUM_MINIONS+1))
    }
  done

  export NUM_MINIONS=$NUM_MINIONS

  echo "Deploy Complete!"
}

# Generate ENV file for nodes to use
#
# Assumed vars:
#   in config-default.sh
function generate_env(){
  cat <<EOF > docker/kube-config/node.env
# Do not modify!
# These ENVs are generated by docker/util.sh#generate_env()
export DNS_SERVER_IP=$DNS_SERVER_IP
export DNS_DOMAIN=$DNS_DOMAIN
export DNS_REPLICAS=$DNS_REPLICAS
export FLANNEL_VERSION=$FLANNEL_VERSION
export ETCD_VERSION=$ETCD_VERSION
export K8S_VERSION=$K8S_VERSION
export NODES="$NODES"
export NONDE_ONLY=$NODE_ONLY
export MASTER=$MASTER
export MASTER_IP=$MASTER_IP
export MASTER_CONF=$MASTER_CONF
export REGISTER_MASTER_KUBELET=$REGISTER_MASTER_KUBELET
export SSH_OPTS="$SSH_OPTS"
export FLANNEL_NET=$FLANNEL_NET
EOF
  cat ${KUBE_ROOT}/cluster/docker/kube-config/node.env

  read -p "Are you sure to continue? (y|n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]
  then
      echo "Abort!"
      exit 1
  fi

}

# Deploy master (or master & node)
#
# Assumed vars:
#   MASTER_IP
#   INFRA
function deploy-node-master() {
  # copy the scripts to the ~/docker directory on the master
  echo "... Deploying Master on machine $MASTER_IP"
  echo
  deploy-node-master-$INFRA
}

# Deploy node
#
# Assumed vars:
#   INFRA
#   node
function deploy-node() {
  # copy the scripts to the ~/docker directory on the node
  echo "... Deploying Node on machine $node"
  echo
  deploy-node-$INFRA
}

# Delete a kubernetes cluster
#
# Assumed vars:
#   INFRA
function kube-down {
  # NOTE kube-dwon can only be called after deployed
  kube-down-$INFRA
  wait
}

# Update a kubernetes cluster with latest source
function kube-push {
  echo "Not implemented"
}

# Perform preparations required to run e2e tests
function prepare-e2e() {
  echo "k8s in docker doesn't have special preparations for e2e tests" 1>&2
}
